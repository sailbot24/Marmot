---
title: "Marmot"
author: "Gavin Adams"
date: "`r Sys.Date()`"
output: html_document
---

```{r,include=FALSE}
devtools::install_github("sailbot24/oRLiDAR")
library(oRLiDAR)
library(terra)
library(sf)
library(dplyr)
library(geoarrow)
library(sfarrow)
library(ForestTools)
library(here)


```

# Set up File Paths for Local Data and if Nessary Convert to Parquets

The here package is great for making sure that the file paths of a project are sorted out easily
## Set the file paths
```{r}
forest_paths <- list(
  gpkg = here("Veg_ShapeFiles", "US_Forest_Service_Proclaimed_Forests", "US_Forest_Service_Proclaimed_Forests.gpkg"),
  parquet = here("Veg_ShapeFiles", "US_Forest_Service_Proclaimed_Forests", "US_Forest_Service_Proclaimed_Forests.siu_grid.parquet")
)

veg_paths <- list(
  gpkg = here("Veg_ShapeFiles", "2003-Veg_Siuslaw", "veg.gpkg"),
  parquet = here("Veg_ShapeFiles", "2003-Veg_Siuslaw", "veg.parquet")
)

grid_paths <- list(
  gpkg = here("Veg_ShapeFiles", "grids", "siu_grid.gpkg"),
  parquet = here("Veg_ShapeFiles", "grids", "siu_grid.parquet")
)

path_config <- list(forest_paths,veg_paths,grid_paths)
```

## Make sure that there is a parquet version of every file
```{r}
ensure_parquet_exists <- function(path_list) {
  if (file.exists(path_list$parquet)) {
    message(basename(path_list$parquet), " exists")
    return(TRUE)
  }
  
  source_file <- if (!is.null(path_list$gpkg) && file.exists(path_list$gpkg)) {
    path_list$gpkg
  } else if (!is.null(path_list$shapefile) && file.exists(path_list$shapefile)) {
    path_list$shapefile
  } else {
    warning("No source file found for ", basename(path_list$parquet))
    return(FALSE)
  }
  
  message("Creating ", basename(path_list$parquet), " from ", basename(source_file))
  sf_obj <- st_read(source_file, quiet = TRUE)
  write_parquet(sf_obj, path_list$parquet)
}

# Run for all configurations
lapply(path_config, ensure_parquet_exists)
```



# Create the Grid
TODO figure out why the gird is rotate 
```{r,include=FALSE}

if(!file.exists(grid_paths$parquet)){
   siu <- st_read(forest_paths$gpkg, layer = "Nat_Forests") %>%
    filter(FORESTNAME == 'Siuslaw National Forest') %>% 
     #st_transform(32610)# UTM zone 10N EPSG code
     st_transform(2992) # Oregon Lambert EPSG Code


  siu_bb <- st_bbox(siu)

  siu_grid<- st_make_grid(siu_bb,
                          c(90,90), #this is the size in meters 
                          what = "polygons", 
                          square = TRUE # make the grid squares
                          )
  siu_grid <- siu_grid %>% 
    st_sf() %>% 
    mutate(grid_id = 1:length(lengths(siu_grid)))
    
  siu_grid <- st_intersection(siu_grid, siu)
  
  siu_grid$SHAPEAREA <- st_area(siu_grid)
  
  siu_grid <- siu_grid %>% select(-GIS_ACRES,-SHAPELEN, -OBJECTID, -FORESTNAME,-PROCLAIMED)
  
  st_write(siu_grid,grid_paths$gpkg, layer = "siu_grid")
  st_write_parquet(siu_grid, grid_paths$parquet)
    
} else {
  siu_grid <- st_read_parquet(grid_paths$parquet)
}

```

# Tree Hight Model 

Testing out the function

```{r}
# simple processing code for now

siu_subset <- siu_grid[25000,] %>% 
  st_transform(2992)
chm_subset <- oRLiDAR::download_oregon_chm(siu_subset)
lin <- function(x){x * 0.05 + 0.6}
ttops <- ForestTools::vwf(chm_subset, winFun = lin, minHeight = 20) # TODO add a catch for if the max tree height is under minHeight 
veg_data <- st_read_parquet(veg_paths$parquet, quiet = TRUE) %>% 
  st_transform(2992)
siu_subset <- st_join(siu_subset, veg_data, join = st_intersects)
siu_subset$height <- mean(ttops$height)

# Tree age calculations 
#TODO tree age calculations go here with better SI calculation 

# Set the constants 
SI <- 105 #TODO change this to be read from the productivity layer, but just use CLass3 for now
bo <- 123.25
b1 <- 0.71698
b2 <- -0.0001677
b3 <- 0.95516
b4 <- 0.0022182

siu_subset$tree_age <- (log((1-siu_subset$height/(bo+b1*SI))^(b3+b4*SI)))/(b2*SI)

# 1. Static Plot (simplified without mean height)
plot_tree_analysis <- function(chm, ttops, title = "Tree Height Analysis") {
  # Plot CHM
  plot(chm, main = paste(title, "\nCanopy Height Model (f)"))
  
  # Convert ttops to SpatVector for plotting if needed
  if (inherits(ttops, "sf")) {
    ttops <- vect(ttops)
  }
  points(ttops, col = "red", cex = 0.6)
  
  # Add histogram
  hist(ttops$height, main = "Tree Height Distribution", 
       xlab = "Height (f)", col = "lightgreen")
  
  message("Tree Height Summary:")
  print(summary(ttops$height))
}

# Run static plot
plot_tree_analysis(chm_subset, ttops)


# Leaflet visualization
leaflet_tree_analysis <- function(chm, ttops, siu_boundary) {
  # Project to WGS84 (EPSG:4326)
  ttops_4326 <- st_transform(ttops, 4326)
  siu_4326 <- st_transform(siu_boundary, 4326)

  # Create palettes
  chm_pal <- colorNumeric("viridis", values(chm), na.color = "transparent")
  height_pal <- colorNumeric("RdYlGn", ttops_4326$height)

  # Convert chm to raster package object
  chm_raster <- as(chm, "Raster")

  leaflet() %>%
    addProviderTiles(providers$Esri.WorldImagery) %>%
    addRasterImage(chm_raster, colors = chm_pal, opacity = 0.8, group = "CHM") %>%
    addCircleMarkers(
      data = ttops_4326,
      radius = 3,
      color = ~height_pal(height),
      fillOpacity = 0.8,
      group = "Tree Tops"
    ) %>%
    addPolygons(
      data = siu_4326,
      color = "red",
      weight = 2,
      fillOpacity = 0.1,
      group = "Boundary"
    ) %>%
    addLegend(
      pal = chm_pal,
      values = values(chm_raster),
      title = "Canopy Height (m)"
    ) %>%
    addLayersControl(
      overlayGroups = c("CHM", "Tree Tops", "Boundary"),
      options = layersControlOptions(collapsed = FALSE)
    ) %>%
    addScaleBar(position = "bottomleft")
}

# Create and view leaflet map
leaflet_map <- leaflet_tree_analysis(chm_subset, ttops, siu_subset)
leaflet_map
```

