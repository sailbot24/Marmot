---
title: "Marmot Tree Height Model"
author: 
  - name: "Gavin Adams"
    affiliation: "Adams Geospatial" 
    url: "https://www.adamsgeospatial.com"
date: "`r Sys.Date()`"
output: 
---

# Libraries

This includes all of the libraries for the project.

```{r setup, include = FALSE}
devtools::install_github("sailbot24/oRLiDAR")
library(oRLiDAR)
library(terra)
library(sf)
library(dplyr)
library(geoarrow)
library(sfarrow)
library(ForestTools)
library(here)
library(leaflet)
library(tmap)
source(".si_function.R")

```

# Set up File Paths for Local Data and if Necessary Convert to Parquets

The here package is great for making sure that the file paths of a project are sorted out easily \## Set the file paths

```{r File Paths}
forest_paths <- list(
  gpkg = here("Veg_ShapeFiles", "US_Forest_Service_Proclaimed_Forests", "US_Forest_Service_Proclaimed_Forests.gpkg"),
  parquet = here("Veg_ShapeFiles", "US_Forest_Service_Proclaimed_Forests", "US_Forest_Service_Proclaimed_Forests.parquet")
)

veg_paths <- list(
  gpkg = here("Veg_ShapeFiles", "2003-Veg_Siuslaw", "veg.gpkg"),
  parquet = here("Veg_ShapeFiles", "2003-Veg_Siuslaw", "veg.parquet")
)

grid_paths <- list(
  gpkg = here("Veg_ShapeFiles", "grids", "siu_grid.gpkg"),
  parquet = here("Veg_ShapeFiles", "grids", "siu_grid.parquet")
)

data_paths <- list(forest_paths,veg_paths,grid_paths)
```

## Make sure that there is a parquet version of every file.

This is to speed up processing time when handling large data sets. Also the size of the files is reduced which helps with sharing on platforms like github.

```{r Parquet, include=FALSE}
ensure_parquet_exists <- function(path_list) {
  if (file.exists(path_list$parquet)) {
    message(basename(path_list$parquet), " exists")
    return()
  }else{
    source_file <- if (!is.null(path_list$gpkg) && file.exists(path_list$gpkg)) {
    path_list$gpkg
  } else{
    warning("No source file found for ", basename(path_list$parquet))
  }
  
  message("Creating ", basename(path_list$parquet), " from ", basename(source_file))
  sf_obj <- st_read(source_file, quiet = TRUE)
  st_write_parquet(sf_obj, path_list$parquet)
  }
}

# Run for all configurations
lapply(data_paths, ensure_parquet_exists)
```

# Create the Grid

Create a gird where each cell is approximately `2` acres covering the Siuslaw National Forest. By first projecting the gird in Oregon Lambert makes sure tha

```{r Create the 2 acre grid} 
#TODO change the names so that they are more generic than for the Siuslaw forest
if(!file.exists(grid_paths$parquet)){
   siu <- st_read(forest_paths$gpkg, layer = "Nat_Forests") %>%
    filter(FORESTNAME == 'Siuslaw National Forest') %>% 
     #st_transform(32610)# UTM zone 10N EPSG code
     st_transform(2992) # Oregon Lambert EPSG Code


  siu_bb <- st_bbox(siu)

  siu_grid<- st_make_grid(siu_bb,
                          c(21780,21780), #this is the size in feet 
                          what = "polygons", 
                          square = TRUE # make the grid squares
                          )
  siu_grid <- siu_grid %>% 
    st_sf() %>% 
    mutate(grid_id = 1:length(lengths(siu_grid)))
    
  siu_grid <- st_intersection(siu_grid, siu)
  
  siu_grid$SHAPEAREA <- st_area(siu_grid)
  
  siu_grid <- siu_grid %>% select(-GIS_ACRES,-SHAPELEN, -OBJECTID, -FORESTNAME,-PROCLAIMED)
  
  st_write(siu_grid,grid_paths$gpkg, layer = "siu_grid")
  st_write_parquet(siu_grid, grid_paths$parquet)
    
} else {
  siu_grid <- st_read_parquet(grid_paths$parquet)
}

```

# Tree Height Model

Testing out the tree age function.

We are still working on a way to get stand productivity from the raster and worked in for SI values.

```{r Tree Height Model, warning=FALSE, include=FALSE}
# simple processing code for now
minHeight <-20 # or other threshold in FT 
probs <- .9 # to take the top 10% of trees. 
siu_subset <- siu_grid[10000,] %>% 
  st_transform(2992)

chm_subset <-tryCatch(
  {oRLiDAR::download_oregon_chm(siu_subset)
  }, error = function(e) {stop("Failed to download CHM: ", e$message)}
  )
chm_subset_max <- terra::minmax(chm_subset)['max',]



#TODO make this more robust, for now it just assigns 9999 for age
if (chm_subset_max <= minHeight){
  siu_subset$tree_age <- 99999
}else{
  lin <- function(x){x * 0.05 + 0.6} # TODO, I think that that the WVF function could use some refinement 
  # the VWF filter that needs to be changed to 
  ttops <- ForestTools::vwf(chm_subset, winFun = lin, minHeight = minHeight) 
  # individual Tree height age 
  ttops$SI <-si_calculator(siu_subset, ttops)
  ttops$Age <- calculate_tree_age(ttops$SI, ttops$height) 
  
  # so that the gird subset has 
  # veg_data <- st_read_parquet(veg_paths$parquet, quiet = TRUE) %>% 
  #   st_transform(2992)
  # siu_subset <- st_join(siu_subset, veg_data, join = st_intersects)
  
  # cull to get the upper canopy top 10% or 5% and then take the mean of that 
  # also keeping the mean height for the stand 
  siu_subset$height_mean <- mean(ttops$height) # Need
  siu_subset$height_top10 <- stats::quantile(ttops$height, probs = .9 )  
  
  
  # Tree age calculations 
  # Set the constants 
  SI <- 105
  bo <- 123.25
  b1 <- 0.71698
  b2 <- -0.0001677
  b3 <- 0.95516
  b4 <- 0.0022182

  # this needs to be 3% command 
  siu_subset$tree_age <- (log((1-siu_subset$height_top10/(bo+b1*SI))^(b3+b4*SI)))/(b2*SI)
}
```

```{r tmap of tree hight model}
#TODO needs to have the chm raster added along with the popup option
# reporject the data to web mapping
#TODO 
tmap_mode("view")# makes the tmap interactive 
# Create the base map
tree_age_map <-  tm_basemap(server = "Esri.WorldImagery")+
  tm_shape(ttops) +
  tm_dots(col = "Age",
          title = "Tree Age",
          style = "cont",  # Continuous color scale
          palette = "YlOrBr",  # Yellow-Orange-Brown palette
          n = 5,  # Number of breaks
          legend.hist = TRUE) +  # Add histogram
  
  # Add map elements
  #tm_compass(type = "8star", position = c("right", "top")) +
  #tm_scale_bar(position = c("left", "bottom")) +
  
  # Layout settings
  tm_layout(main.title = "Estimated Tree Height by Grid Cell",
            main.title.position = "center",
            legend.outside = TRUE,
            legend.outside.position = "right",
            frame = FALSE,
            bg.color = "white",
            inner.margins = c(0.1, 0.1, 0.1, 0.1))


# Print the map
tree_age_map

```

## VWF Function Testing

```{r}

tmap_mode("view")

# segmented functions 
segmented_vwfs <- list(
  Seg1 = function(x) ifelse(x < 15, 0.1 * x + 0.5, 0.02 * x + 1.25),
  Seg2 = function(x) ifelse(x < 15, 0.12 * x + 0.4, 0.02 * x + 1.3),
  Seg3 = function(x) ifelse(x < 18, 0.08 * x + 0.6, 0.015 * x + 1.4),
  Seg4 = function(x) ifelse(x < 15, 0.1 * x + 0.5, 0.05 * x + 1.0),
  Seg5 = function(x) ifelse(x < 15, 0.09 * x + 0.55, 0.01 * x + 1.5),
  Seg6 = function(x) 0.06 * x + 1
)



# Function: Run VWF with All Segment Variants
get_vwf_ttops <- function(chm, min_height = min_height) {
  ttops_list <- list()
  
  for (name in names(segmented_vwfs)) {
    cat("Running VWF:", name, "\n")
    
    ttops_testing <- vwf(chm, winFun = segmented_vwfs[[name]], minHeight = min_height)
    ttops_testing$name <- name  # Add function name for faceting
    ttops_list[[name]] <- ttops_testing
  }
  
  return(ttops_list)
}

ttops_list <- get_vwf_ttops(chm=chm_subset, min_height = 2)

# Combine all into one `sf` object
ttops_all <- do.call(rbind, ttops_list)


tm_shape(chm_subset) +
  tm_raster(style = "cont", palette = "viridis", title = "CHM Height") +
tm_shape(ttops_all) +
  tm_symbols(col = "red", size = 0.05) +
  tm_facets(by = "name", free.coords = FALSE, drop.units = TRUE) +
  tm_layout(legend.outside = TRUE, title = "Tree Tops by VWF Function")

```
```{r}

# Count number of trees per function
ttops_counts <- lapply(ttops_list, nrow)

# Convert to a tidy data frame
ttops_summary <- data.frame(
  Function = names(ttops_counts),
  Tree_Count = unlist(ttops_counts)
)

# View the results
print(ttops_summary)
library(ggplot2)

ggplot(ttops_summary, aes(x = Function, y = Tree_Count, fill = Function)) +
  geom_col(show.legend = FALSE) +
  theme_minimal() +
  labs(title = "Tree Counts by Segmented VWF Function",
       x = "Function", y = "Number of Detected Trees")
```

```{r testing on the Peav4}
peav4 <- here(
  "output", 
 "Peav4.tif" 
)
chm_peav4 <- rast(peav4)
bb_peav4 <-st_bbox(peav4)
```

```{r}
```
